% Edina Rosta
% edina.rosta@kcl.ac.uk

clear all 
close all

fprintf('Section 1: Generating random rate matrix')

% N = number of states
% K(i,j) rate constant for the i --> j process
% rand is a subroutine that generates a uniformly
% distributed random number between (0,1)
N=4;
for i=1:N-1
	K(i,i+1)=10*rand;
	K(i+1,i)=10*rand;
end
% Add a stochastic "bottle neck" between states 2 and 3, by setting smaller rates here
K(2,3)=rand;
K(3,2)=rand;
for i=1:N
	K(i,i)=-sum(K(:,i));
end

display(K)

%% 

fprintf('Section 2: Spectral decomposition (getting eigenvalues/vectors) and finding equilibrium probability vector')

%calculate equilibrium from spectral decomposition
[eigvec,eigval]=eig(K); % diagonalize K, eigvec stores the eigenvectors, eigval the eigenvalues

display(eigval)

[dsorted,index]=sort(diag(eigval),'descend'); % sort the eigenvalues. dsorted stores the eigenvalues, index the corresponding indices
% sorted eigenvalues:
ind=index(1); %index corresponding to 0 eigenvalue
eq=eigvec(:,ind)/sum(eigvec(:,ind)); % equilibrium probability corresponds to 0 eigenvalue. Based on the equilibrium probability we can also obtain the energy.

display(eq)

% Plot of sorted eigenvalues
figure
hold on
x=linspace(1,N,N);
plot(x,dsorted,'o')
ylabel('Eigenvalue','FontSize',18)
%% 

fprintf('Section 3: Calculating equilibrium energies ')

kB=0.0019872041; % Boltzmann constant (kcal/mol)
temp=298; % Temperature
energy=kB*temp*(-log(eq));% calculate the energy
energy=energy-min(energy); %
% Now we plot the energies...
figure
hold on
xlabel('# State','FontSize',18)                   
ylabel('\DeltaG (kcal/mol)','FontSize',18)
bar(energy,'r')
% plot(energy,'b-o','MarkerSize',10)
% hold off

%% 

fprintf('Section 4: Finding second right eigenvector')

% splitting and eigvec
[eigvec,eigval]=eig(K'); % diagonalize K, eigvec stores the right eigenvectors
[dsorted,index]=sort(diag(eigval),'descend'); % sort the eigenvalues. 

display(dsorted)

slowest_relrate=-dsorted(2);
slow_vec=eigvec(:,index(2));

figure
hold on
bar(slow_vec)
xlabel('# State','FontSize',18)
ylabel('Second eigenvector','FontSize',18)
hold off
%% 

fprintf('Section 5: Using gillespie algorithm to generate trajectories')

% Run Gillespie to obtain trajectories ..................................
for i=1:N
  for j=1:N
    if ( i ~= j ) % i =\= j 
       p(j,i)=K(j,i)/(-K(i,i));
    end
  end
end

for j=1:N
pp(1,j)=0;
for i=1:N
  pp(i+1,j)=sum(p(1:i,j)); % The pp matrix stores cumulative transition probabilities
end
end

s=1; %starting state
time=0; 
tcum=zeros(N,1); % creates a vector of N elements
NN=50000; % Number of transitions
for k=1:NN
        tadd=1/K(s,s)*log(rand); % tadd is the survival time the system stays in state s. It is calculated based on a single exponential decay for the survival time.
        time=time+tadd; %time=total time
        t_traj(k)=time; %t_traj matrix saves information about the survival times
        s_traj(k)=s;    %s_traj matrix saves information about the current state
        
        ss=find(histc(rand,pp(:,s))); % finds the new state
        tcum(s)=tcum(s)+tadd; % total time that the system spends in state s
        s=ss; %the new state is ss
end
measured_eq=tcum/sum(tcum); %average time spent in each state / total time = measured euqilibrium probability (p_eq)
%% 

fprintf('Section 6: Comparing the true eigenvector to the trajectories estimate')

display(eq)
display(measured_eq);

% Compare analytical and measured p_eq
figure
hold on
xlabel('# State','FontSize',18)                   
ylabel('Equilibrium probability','FontSize',18)
bar(eq,'r')
bar(measured_eq,'b', 'BarWidth',0.4)
legend('exact','measured')
%% 

fprintf('Section 7: Viewing the trajectory generated by the Gillespie algorithm')

bins=100;
tim=linspace(0,t_traj(end),NN*bins); % We discretize the time
ind=1;

for i=1:NN*bins % we have NN transitions and we have divided the timescale in 100*NN steps
   while tim(i) > t_traj(ind)
      ind=ind+1;
   end
   state(i)=s_traj(ind);
end

% Plot of trajectory
figure
hold on
plot(state(1:NN*bins)) % We plot the whole trajectory. Lets zoom in!!!
xlabel('time','FontSize',18)
title('Trajectory','FontSize',24)
ylabel('# State','FontSize',18)
hold off

figure
hold on
plot(state(1:15000 )) % 
%plot(state(NN-4999:NN),'r') % Uncoment to add more parts of the trajectory
xlabel('time','FontSize',18)
title('Trajectory - Zoom in!','FontSize',24)
ylabel('# State','FontSize',18)
hold off
%% 

fprintf('Section 8: Comparison of autocorrelation function and slowest relaxation rate')

[ACF,lags,bounds] = autocorr(state,10000); 
% autocorrelation function of the state.Change the lagtime up to 10000
%autocorr(state,10000) %uncomment to see how the autocorrelation function looks. 

figure
plot(tim(1+lags),log(ACF),'LineWidth',2)
hold on
x=linspace(0,10,100);
plot(x,-slowest_relrate*x,'r-','LineWidth',2) 
% the mean of the log autocorrelation function is the second smaller eigenvalue
legend('autocorrelation function','slowest relaxation rate')
xlabel('Time','FontSize',18)
ylabel('ln(ACF)','FontSize',18)
%% 

fprintf('Section 9: Construction of Markov chain from time spent in each state')

% Construct Markov chain
lagtime=1;
qspace=(1:N+1);
ncount(1:N+1)=histc(state(1:end-lagtime),qspace);

MM=zeros(N,N);
Nstep=size(state,2); % 
for i=1+lagtime:Nstep
    MM(state(i-lagtime),state(i))=MM(state(i-lagtime),state(i))+1/ncount(state(i-lagtime));           
end

msum=sum(MM');
for i=1:N
    if msum(i) > 0
        MM(i,:)=MM(i,:)/msum(i);
    else
        MM(i,:)=0;
    end
end

display(MM')

% this is equivalent with the matrix exponential of the rate matrix:
display(expm(K*tim(2)))
%% 

fprintf('Section 10: Comparison of Markov chain and original rate matrix properties')

[eigvecM,eigvalM]=eig(MM'); % diagonalize K, eigvec stores the eigenvectors, eigval the eigenvalues
[dsortedM,indexM]=sort(diag(eigvalM),'descend'); % sort the eigenvalues. dsortes stores the eigenvalues, index the corresponding indices
slowest_relrateM=-log(dsortedM(2))/tim(2); % compare to slowest_relrate=-dsorted(2)

display(slowest_relrateM)
display(slowest_relrate)

%Sorted eigenvalues of Markov chain
display(dsortedM)

% the equilibrium eigenvector from the Markov chain:
ind=indexM(1);
eqM=eigvecM(:,ind)/sum(eigvecM(:,ind));

display(eqM)
display(eq)

% Compare analytical and measured p_eq
figure
hold on
xlabel('# State','FontSize',18)
ylabel('Equilibrium probability','FontSize',18)
bar(eq,'r')
bar(eqM,'b', 'BarWidth',0.4)
legend('exact','Markov chain')